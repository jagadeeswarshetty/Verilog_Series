--> Gate-level modeling describes a digital circuit by representing it as a collection of interconnected basic logic gates, such as AND, OR, and NOT gates, along with their connections and specified delays.
--> Only gate-level primitives (and, or, xor, nand, nor, not)

--> Clear module names, inputs, outputs

Comment lines for explanation

ðŸ”¹ 1. Half Adder
module half_adder (input A, B, output Sum, Carry);
    xor (Sum, A, B);   // Sum = A âŠ• B
    and (Carry, A, B); // Carry = A â‹… B
endmodule

ðŸ”¹ 2. Full Adder
module full_adder (input A, B, Cin, output Sum, Cout);
    wire s1, c1, c2;
    
    xor (s1, A, B);       // A âŠ• B
    xor (Sum, s1, Cin);   // (A âŠ• B) âŠ• Cin
    
    and (c1, A, B);       // AB
    and (c2, s1, Cin);    // (A âŠ• B) Cin
    or  (Cout, c1, c2);   // AB + (A âŠ• B)Cin
endmodule

ðŸ”¹ 3. HA and FA using NAND gates

(Example: HA)

module half_adder_nand (input A, B, output Sum, Carry);
    wire n1, n2, n3;
    nand (n1, A, B);
    nand (n2, A, n1);
    nand (n3, B, n1);
    nand (Sum, n2, n3);   // XOR using NAND
    nand (Carry, n1, n1); // AND using NAND
endmodule


(FA can be extended using 2 HAs + OR with NAND implementation)

ðŸ”¹ 4. Full Adder using 2 Half Adders
module full_adder_using_ha (input A, B, Cin, output Sum, Cout);
    wire s1, c1, c2;
    
    // First HA
    xor (s1, A, B);
    and (c1, A, B);
    
    // Second HA
    xor (Sum, s1, Cin);
    and (c2, s1, Cin);
    
    // Final carry
    or (Cout, c1, c2);
endmodule

ðŸ”¹ 5. Half Subtractor
module half_subtractor (input A, B, output Diff, Borrow);
    xor (Diff, A, B);     // Difference = A âŠ• B
    and (Borrow, ~A, B);  // Borrow = Aâ€™B
endmodule

ðŸ”¹ 6. Full Subtractor
module full_subtractor (input A, B, Bin, output Diff, Bout);
    wire d1, b1, b2;
    
    xor (d1, A, B);
    xor (Diff, d1, Bin);
    
    and (b1, ~A, B);
    and (b2, ~d1, Bin);
    or  (Bout, b1, b2);
endmodule

ðŸ”¹ 7. Full Subtractor using 2 Half Subtractors
module full_subtractor_using_hs (input A, B, Bin, output Diff, Bout);
    wire d1, b1, b2;
    
    // First HS
    xor (d1, A, B);
    and (b1, ~A, B);
    
    // Second HS
    xor (Diff, d1, Bin);
    and (b2, ~d1, Bin);
    
    // Final borrow
    or (Bout, b1, b2);
endmodule

ðŸ”¹ 8. Ripple Carry Adder (4-bit Example)
module ripple_carry_adder_4bit(input [3:0] A, B, input Cin, output [3:0] Sum, output Cout);
    wire c1, c2, c3;
    
    full_adder fa0 (A[0], B[0], Cin,  Sum[0], c1);
    full_adder fa1 (A[1], B[1], c1,   Sum[1], c2);
    full_adder fa2 (A[2], B[2], c2,   Sum[2], c3);
    full_adder fa3 (A[3], B[3], c3,   Sum[3], Cout);
endmodule

ðŸ”¹ 9. BCD Adder (basic structure)

Needs correction logic (add 6 if >9). For GitHub, better to implement 4-bit binary adder + correction logic.

ðŸ”¹ 10. Code Converters (Example: Binary â†’ Gray)
module binary_to_gray(input [3:0] B, output [3:0] G);
    assign G[3] = B[3];
    assign G[2] = B[3] ^ B[2];
    assign G[1] = B[2] ^ B[1];
    assign G[0] = B[1] ^ B[0];
endmodule

ðŸ”¹ 11. Comparator (1-bit)
module comparator_1bit (input A, B, output AeqB, AgtB, AltB);
    xnor (AeqB, A, B);
    and  (AgtB, A, ~B);
    and  (AltB, ~A, B);
endmodule

ðŸ”¹ 12. 2:1 Multiplexer
module mux2_1 (input I0, I1, S, output Y);
    wire nS, w1, w2;
    not (nS, S);
    and (w1, I0, nS);
    and (w2, I1, S);
    or  (Y, w1, w2);
endmodule

ðŸ”¹ 13. 4:1 Multiplexer using 2:1
module mux4_1 (input [3:0] I, input [1:0] S, output Y);
    wire w1, w2;
    mux2_1 m1 (I[0], I[1], S[0], w1);
    mux2_1 m2 (I[2], I[3], S[0], w2);
    mux2_1 m3 (w1, w2, S[1], Y);
endmodule

ðŸ”¹ 14. Encoder (4-to-2)
module encoder4_2 (input [3:0] D, output [1:0] Y);
    assign Y[1] = D[2] | D[3];
    assign Y[0] = D[1] | D[3];
endmodule

ðŸ”¹ 15. Decoder (2-to-4)
module decoder2_4 (input [1:0] A, output [3:0] Y);
    wire n0, n1;
    not (n0, A[0]);
    not (n1, A[1]);
    
    and (Y[0], n1, n0);
    and (Y[1], n1, A[0]);
    and (Y[2], A[1], n0);
    and (Y[3], A[1], A[0]);
endmodule
